#!/usr/bin/env python3
from importlib.machinery import SourceFileLoader
from importlib.util import module_from_spec,spec_from_loader
from os import listdir,mkdir
from os.path import abspath,basename,dirname,expanduser,isfile,join,realpath
from shutil import copytree,rmtree
from selinux import getfilecon
from subprocess import run
from sys import argv,exit

######################
### CUSTOM MODULES ###
######################
def custom_module(filename):
    # Define the name based on the filename
    name = basename(filename)
    # Create $spec that is used to load the module
    spec = spec_from_loader(name, SourceFileLoader(name, filename))
    # Define the module
    mod = module_from_spec(spec)
    # Load the module based on $spec
    spec.loader.exec_module(mod)
    # Return the module object
    return(mod)

#-------------#
#-- SEINFOX --#
#-------------#
# Since the `seinfox` module does not have the '.py' extension, it needs to be loaded in a more complicated way
seinfox = custom_module(join(dirname(argv[0]), 'seinfox'))

# Define the contexts function as $contexts
contexts = seinfox.contexts

#------------------#
#-- SEMODGENAUTO --#
#------------------#
# Load the `semodgenauto` python script
semodgenauto = custom_module(join(dirname(argv[0]), 'semodgenauto'))

# Define the main function as $semodgenauto
semodgenauto = semodgenauto.main

#############
### USAGE ###
#############
def usage():
    name = basename(argv[0])
    print(f"NAME\n\t{name} - python script to automatically generate a SELinux policy module for all binaries and libraries within the specified package\n")
    print(f"SYNOPSIS\n\t{name} package_name /path/to/output_dir/\n")
    print(f"DESCRIPTION\n\t{name} is a Python script provided by the HardHat project that automatically generates a single SELinux policy module (label only) for all of the binaries within the package labelled as 'bin_t', and all of the libraries within the package labelled as 'lib_t'. The label will be based on the package's name, eg. Binaries within the 'coreutils' package will have the label 'coreutils_bin_t', and the libraries will be labelled 'coreutils_lib_t'.\n\n\tArgument 2 is optional, and it specifies the directory to output the SELinux policy module directory to. By default, this is set to: '/usr/local/share/hardhat-selinux-local'\n")
    print(f"EXAMPLE\n\t1. {name} coreutils\n\n\t2. {name} gzip /home/user/selinux-labels\n")
    print("\n")

#################
### FUNCTIONS ###
#################
def args():
    # Check if the user has specified the help flag (any argument)
    if any([True for arg in argv if arg == '-h']):
        # If so, then display the usage information
        usage()
        # Exit
        exit(0)
    try:
        package = argv[1]
    except IndexError:
        # Display usage information to the user
        usage()
        # Display error message to user
        print('ERROR: Argument 1: Name of the package')
        # Exit with an error
        exit(1)
    # Define the directory where the SELinux policy module directory will be created in
    try:
        outdir = expanduser(argv[2])
    except IndexError:
        # Default output directory
        outdir = expanduser('/usr/local/share/hardhat-selinux-local')
    # Return the arguments passed by the user
    return(package, outdir)

class contents:
    def __init__(self, package):
        # Obtain the set containing all files associated with $package
        raw = self.rpm(package)
        # List of all binaries within $package that are labeled as 'bin_t', a generic label
        self.bin_t = self.generic(raw, ('/bin', '/sbin', '/usr/bin', '/usr/sbin'), 'bin_t')
        # List of all binaries within $package that are labeled as 'lib_t', a generic label
        lib_t = self.generic(raw, ('/usr/lib'), 'lib_t')
        # Filter the $lib_t list
        self.lib_t = self.lib(lib_t)

    def __call__(self):
        return(self.bin_t, self.lib_t)

    def rpm(self, package):
        cmd = run(['/usr/bin/rpm', '-q', '-l', package], capture_output = True)
        # Obtain the output from the $cmd, decode it, and remove extraneous whitespaces
        stdout = cmd.stdout.decode().strip()
        # If the returncode was 1, then an error occured
        if cmd.returncode == 1:
            # Display the $stdout which contains the error message from `rpm`
            print(f"ERROR: Command failed: '{stdout}'")
            # Exit with an error
            exit(1)
        # Create a set that contains every entry within $stdout, but remove extraneous whitespace from each entry and also ensure that all entries are non-empty. Finally, a the list is converted into a set to remove duplicates
        raw = set([entry.strip() for entry in stdout.split('\n') if entry])
        # Return the $raw set
        return(raw)

    def symlink(self, entry):
        try:
            # If $entry is a symlink, then obtain the full path to the real file
            entry = realpath(entry)
        except OSError:
            # Otherwise, $entry is not a symlink, so do nothing
            pass
        # Return $entry
        return(entry)

    def generic(self, raw, paths, generic_t):
        # Define a list of all entries within any of the $paths above
        entries = [entry for entry in raw if entry.startswith(paths)]
        # Create a complete set of all entries that contains symlinks as well as their targets
        entries = set(entries + [self.symlink(entry) for entry in entries])
        # Define a list that will contain the path to all entries that are labeled $generic_t, which is a generic label
        gen_t = []
        # Iterate through all entries within the $entries list
        for entry in entries:
            # Skip all entries that start with the specified string
            if entry.startswith('/usr/lib/.build-id'): continue
            try:
                # Obtain the SELinux type context for the current entry
                [_, _, setype] = contexts(entry)
            except PermissionError:
                # If the specified path is not accessible by the user that executed this script, then display a warning message to user
                print(f"WARN: Unable to obtain the SELinux context for the following entry due to a permission error. You may need to run this script as root: '{entry}'")
                continue
            except FileNotFoundError:
                # If $entry is not a valid file, then display a warning message to user
                print(f"WARN: The following entry is not a valid file. This error occurs when a package's symlink is to a non-existent file and is often harmless: '{entry}'")
                # Skip this entry
                continue
            # If the label is generic, then add $entry to the $gen_t list
            if setype == generic_t: gen_t.append(entry)
        # Set $gen_t to False if it's empty
        if not gen_t: gen_t = False
        # Return $gen_t
        return(gen_t)

    def lib(self, lib_t):
        # If $lib_t is False then return immediately
        if (lib_t is False): return(lib_t)
        # Only keep entries that have 'so' in the name once split via '.'
        lib_t = [entry for entry in lib_t if 'so' in entry.split('.')]
        # If there is nothing left in $lib_t, then return False
        if not lib_t: return(False)
        # Otherwise, return the new $lib_t list
        return(lib_t)

class selinux:
    def __init__(self, package, bin_t, lib_t):
        # Ensure that at least one of the lists have entries
        self.valid(bin_t, lib_t)
        # Generate the SELinux policy module directory label for the binary package(s)
        self.bin_dir = self.generate(package, bin_t, f"{package}_bin_t", f"{package}_bin")
        # Check if the $package name ends with 'libs'
        if package.endswith('libs'):
            # If so, then the SELinux policy module label will simply add '_t' to the end of the package name to define the type label
            libtypelabel = f"{package}_t"
        else:
            # Otherwise, add the specified string to the end of the $package name
            libtypelabel = f"{package}_lib_t"
        # Generate the SELinux policy module directory label for the library package(s)
        self.lib_dir = self.generate(package, lib_t, libtypelabel, f"{package}_lib")
        
    def __call__(self):
        # Return the SELinux policy module directory
        return(self.bin_dir, self.lib_dir)

    def valid(self, bin_t, lib_t):
        # Check if both $bin_t and $lib_t are False
        if (bin_t is False) and (lib_t is False):
            # If so, then display an error message to user
            print('ERROR: There are no binaries of type \'bin_t\' or libraries of type \'lib_t\'')
            # Exit with an error
            exit(1)

    def generate(self, package, type_t, label, dirname):
        try:
            # Define only the first entry
            type_t = type_t[0]
        except TypeError:
            # If $type_t is False, then return
            return(False)
        # Define the full path to the SELinux policy module directory
        selinux_dir = join('/tmp', dirname)
        try:
            # Remove $selinux_dir if it already exists
            rmtree(selinux_dir)
        except FileNotFoundError:
            # If $selinux_dir doesn't exist, then do nothing
            pass
        # Create a SELinux policy module directory in /tmp just for $type_t. The label.sh file will be edited to specify the rest of the $bin_t list as well as the $lib_t list too
        semodgenauto(type_t, '/tmp', label, dirname)
        # Return the directory
        return(selinux_dir)

class merge:
    def __init__(self, package, bin_dir, lib_dir):
        # Obtain the contents of the label.sh and te file from $bin_dir
        [bin_label, bin_te] = self.contents(bin_dir)
        # Obtain the contents of the label.sh and te file from $lib_dir
        [lib_label, lib_te] = self.contents(lib_dir)
        # Merge the contents of $bin_label and $lib_label
        self.label = self.labels([bin_label, lib_label])
        # Merge the contents of $bin_te and $lib_te
        [self.te, self.module] = self.tes([bin_te, lib_te], f"{package}_label")

    def __call__(self):
        # Return the merged label and te file contents
        return(self.label, self.te, self.module)

    def read(self, filename):
        try:
            # Open $filename and return its contents
            with open(filename, 'r') as f: return(f.readlines())
        except FileNotFoundError:
            # If $filename does not exist, then return False
            return(False)

    def contents(self, directory):
        try:
            # Obtain the contents of the 'label.sh' file for the current SELinux policy module directory
            label = self.read(join(directory, 'label.sh'))
        except TypeError:
            # If a TypeError is raised, then $directory is False, meaning there were no files associated with $directory (which is either $bin_t or $lib_t). So return False for both the label and te file contents
            return(False, False)
        # Obtain the first (and only) te file within $directory
        te = [join(directory, f) for f in listdir(directory) if f.endswith('.te')][0]
        # Obtain the contents of the SELinux policy module file
        te = self.read(te)
        # Check if $te is False, meaning the file was not found in $directory
        if te is False:
            # If so, then display an error message to user
            print(f"ERROR: Unable to find the SELinux '.te' file within: '{directory}'")
            # Exit with an error
            exit(1)
        # Return the contents for the label and te file within $directory
        return(label, te)

    def labels(self, all_lst):
        # Define the output list
        label = []
        # Iterate through each list within $all_lst
        for lst in all_lst:
            try:
                # Add every single within $lst to the $label list. This will make $label a list of lists
                label.append(lst[1:])
            except TypeError:
                # If the current $lst is False, then do nothing
                pass
        # Add the header and unnest each entry within the $label list
        label = ['#!/bin/sh\n'] + [entry[0] for entry in label]
        # Return the merged $label list
        return(label)

    def attributes(self, all_te, index):
        # The $index line is where the section are located in the file
        attr = [lst[index] for lst in all_te if (lst is not False)]
        # Add the beginning of the line back
        attr = [entry.replace(';', '') for lst in attr for entry in lst.split()[1:]]
        # Ensure all entries have a comma at the end of them
        attr = [f"{entry}," if not entry.endswith(',') else entry for entry in attr]
        # Remove duplicate entries and sort in alphabetical order
        attr = sorted(set(attr))
        # Remove the comma from the last entry
        attr[-1] = attr[-1].replace(',', '')
        # Add the semicolon that goes at the end of the line to the last entry in $attr 
        attr[-1] = f"{attr[-1]};\n"
        # Return the $attr list
        return(attr)

    def tes(self, all_te, module):
        # Define the output list
        te = []
        #------------#
        #-- HEADER --#
        #------------#
        # Define the header for the merged te file
        header = [f"module {module} 1.0.0;\n"] + [lst[1:3] for lst in all_te if (lst is not False)][0]
        #---------------#
        #-- SEPARATOR --#
        #---------------#
        # The separator will be the second line within the $header
        separator = header[1]
        #---------------#
        #-- ATTRIBUTE --#
        #---------------#
        # Merge the attributes from all files into one
        attribute = self.attributes(all_te, 3)
        # Add the beginning of the section and the ending of the 'require' section
        attribute = ['    attribute'] + attribute + ['}\n']
        #----------#
        #-- TYPE --#
        #----------#
        # Obtain all unique $types from each $lst within $all_te
        types = sorted(set([lst[6].strip() for lst in all_te if (lst is not False)]))
        # Add a newline to the end of the $types list
        types[-1] = f"{types[-1]}\n"
        #
        # Join all parts together to create the te file
        te = ''.join(header) + ' '.join(attribute) + separator + '\n'.join(types) + separator
        # Return $te
        return(te, module)

def rm(directory):
    try:
        # Remove $directory
        rmtree(directory)
    except TypeError:
        # If $directory is False, then do nothing
        pass

class create:
    def __init__(self, label, te, module, outdir):
        # Create the SELinux policy module directory in $outdir
        directory = self.makedir(module, outdir)
        # Write the 'label.sh' file
        self.write(directory, label, 'label.sh')
        # Write the '.te' file
        self.write(directory, te, f"{module}.te")
        # Make $directory a global variable so it can be returned
        self.directory = directory

    def __call__(self):
        # Return the new $directory
        return(self.directory)

    def makedir(self, module, outdir):
        # Define the SELinux policy module directory
        directory = join(outdir, module)
        try:
            # Create the directory
            mkdir(directory)
        except FileExistsError:
            # If the directory already exists, then do nothing
            pass
        # Return $directory
        return(directory)

    def module(self, te):
        # $te is a string, so split it via the newline delimiter and obtain the first line
        first = te.split('\n')[0]
        # Split the first line and obtain the index of the 'module' string
        i = [first.index(entry) for entry in first.split() if entry.strip() == 'module']
        try:
            # The name of the module will be the index after $i
            name = first[i[0] + 1]
        except IndexError:
            # If the $name could not be defined above, display an error message to user
            print('ERROR: Unable to obtain the name of the SELinux policy module')
            # Exit with an error
            exit(1)
        # Return the module $name
        return(name) 

    def write(self, directory, contents, filename):
        with open(join(directory, filename), 'w') as f: f.write(''.join(contents))

class edit:
    def __init__(self, package, directory, bin_t, lib_t):
        # Obtain the 'label.sh' file from the SELinux policy module directory as well as its contents
        [label_sh, contents] = self.label(directory, bin_t, lib_t)
        # Define the `semanage` command used to label files and directories for SELinux
        cmd = self.semanage(contents)
        # Keep only the header of the file since the existing contents are not needed
        contents = [contents[0]]
        # Add all entries from $bin_t to the $contents list
        contents = self.add(bin_t, contents, cmd, f"{package}_bin_t")
        # Check if the $package name ends with 'libs'
        if package.endswith('libs'):
            # If so, then the SELinux policy module label will simply add '_t' to the end of the package name to define the type label
            libtypelabel = f"{package}_t"
        else:
            # Otherwise, add the specified string to the end of the $package name
            libtypelabel = f"{package}_lib_t"
        # Add all entries from $lib_t to the $contents list
        contents = self.add(lib_t, contents, cmd, libtypelabel)
        # Overwrite $label_sh with the new $contents
        self.write(label_sh, contents)

    def label(self, directory, bin_t, lib_t):
        # Define the full path to the 'label.sh' shell script to edit
        label_sh = join(directory, 'label.sh')
        try:
            # Open the $label_sh and obtain its existing contents
            with open(label_sh, 'r') as f: contents = f.readlines()
        except FileNotFoundError:
            # If the file cannot be found, then display an error message
            print(f"ERROR: Unable to open the following file for editing: '{label_sh}'")
            # Exit with an error
            exit(1)
        # Return the $label_sh and its $contents
        return(label_sh, contents)

    def semanage(self, contents):
        try:
            # Define the `semanage` command from $label_sh
            cmd = [entry for entry in contents if entry.startswith('/usr/sbin/semanage')][0]
        except IndexError:
            # If the `semanage` command could not be found in $label_sh, display an error message
            print("ERROR: Unable to extract the `semanage` command from the following file: '{label_sh}'")
            # Exit with an error
            exit(1)
        # Define the command to include everything but the path to the file/directory to be labeled
        #cmd = ' '.join(cmd.split()[0:-1])
        cmd = cmd.split()[0:-1]
        # Return the $cmd
        return(cmd)

    def add(self, gen_t, contents, cmd, label):
        try:
            # Obtain the existing label from the $cmd list
            curr_label = [cmd[i + 1] for i in range(len(cmd)) if cmd[i] == '--type'][0]
        except IndexError:
            # If the label could not be obtained, then display an error message to user
            print(f"ERROR: Unable to obtain the existing type label for: {cmd}\n")
            # Exit with an error
            exit(1)
        # Join the $cmd now that the label has been obtained
        cmd = ' '.join(cmd)
        try:
            # Define the list of commands that label each entry in $gen_t
            gen_t_contents = [f"{cmd} {entry};\n" for entry in gen_t]
        except TypeError:
            # If $gen_t is a boolean, return $contents as-is
            return(contents)
        # Change the existing ${package}_t label to either ${package}_bin_t for binaries or ${package}_lib_t for libraries
        gen_t_contents = [entry.replace(curr_label, label) for entry in gen_t_contents]
        # Change the path of '/usr/lib64' to '/usr/lib' if applicable
        gen_t_contents = [entry.replace('/usr/lib64', '/usr/lib') for entry in gen_t_contents]
        # Add $gen_t_contents to the existing $contents list
        contents = contents + gen_t_contents
        # Remove duplicates from everything but the first line, which is the shebang
        contents = [contents[0]] + sorted(set(contents[1:]))
        # Return the new $contents
        return(contents)

    def write(self, label_sh, contents):
        # Overwrite $label_sh with $contents
        with open(label_sh, 'w') as f: f.write(''.join(contents))

############
### MAIN ###
############
def main(package, outdir):
    # Obtain the list of binaries ($bin_t) and libraries ($lib_t) to create labels for
    [bin_t, lib_t] = contents(package)()
    # Use the `semodgenauto` script to create SELinux policy module directories for $bin_t and $lib_t, which are the return variables
    [bin_dir, lib_dir] = selinux(package, bin_t, lib_t)()
    # Merge the files within the directories into one
    [label, te, module] = merge(package, bin_dir, lib_dir)()
    # Remove the temporary directories
    rm(bin_dir)
    rm(lib_dir)
    # Create the output SELinux policy module directory
    directory = create(label, te, module, outdir)()
    # Edit the shell script that defines the SELinux labelling to include all entries within $bin_t and $lib_t
    edit(package, directory, bin_t, lib_t)
        
#############
### START ###
#############
if __name__ == '__main__':
    # Obtain the arguments from user
    [package, outdir] = args()
    # Start the main function
    main(package, outdir)
