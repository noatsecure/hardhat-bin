#!/usr/bin/env python3
from importlib.machinery import SourceFileLoader
from importlib.util import module_from_spec,spec_from_loader
from os import getcwd
from pathlib import Path,PurePath
from shutil import copytree,move
from sys import argv,exit

######################
### CUSTOM MODULES ###
######################
# Path to the module; should be in the name directory as this script
path_seinfox = PurePath(PurePath(Path(argv[0]).resolve()).parent).joinpath('seinfox').as_posix()

# Since the `seinfox` utility does not have the '.py' extension, it needs to be loaded in a special way
spec = spec_from_loader('seinfox', SourceFileLoader('seinfox', path_seinfox))
seinfox = module_from_spec(spec)
spec.loader.exec_module(seinfox)

# Load the function that obtains the raw attributes for the given type
description = seinfox.description

# Load the function that parses the attributes obtained from the `description` function and removes aliases
ignore_alias = seinfox.ignore_alias

# Define the main function as $seinfox
seinfox = seinfox.main

###################
### DIRECTORIES ###
###################
# Full path to the directory containing the template SELinux policy module and shell script for labelling
template = Path('/usr/local/src/hardhat-selinux-templates/labels').expanduser()

################
### BINARIES ###
################
seinfo = Path('/usr/bin/seinfo').expanduser()

#############
### USAGE ###
#############
def usage():
    name = PurePath(argv[0]).name
    print(f"NAME\n\t{name} - python script to automatically generate a SELinux policy module for the specified file/directory\n")
    print(f"SYNOPSIS\n\t{name} /path/to/file_or_dir [OPTIONS]\n")
    print(f"DESCRIPTION\n\t{name} is a Python script provided by the HardHat project that automatically generates a SELinux policy module (label only) for the specified file/directory.\n")
    print(f"OPTIONS\n\t-d\tDirectory to output the generated SELinux policy module directory\n\t-h\tDisplay this message\n\t-l\tCustom label to use\n\t-n\tName of the SELinux policy module directory to create\n\t-t\tSpecific SELinux type to use for the module attributes (eg. 'bin_t')\n")
    print(f"EXAMPLE\n\t1. {name} /usr/bin/cat\n\n\t2. {name} /usr/bin/cat -d /home/user/selinux\n\n\t3. {name} /usr/bin/cat -l custom_label_t\n\n\t4. {name} /usr/bin/cat -d ~/output_dir -l custom_label_t\n\n\t5. {name} /usr/bin/cat -d /tmp -l label_t -n cat_label_dir\n")
    print("\n")

#################
### FUNCTIONS ###
#################
def args():
    # Check if the user has specified the help flag (any argument)
    if any([True for arg in argv if arg == '-h']):
        # If so, then display the usage information
        usage()
        # Exit
        exit(0)
    try:
        # Argument 1: Full path to the file/directory to generate a label for
        target = Path(Path(argv[1]).expanduser()).resolve().as_posix()
    except IndexError:
        # If argument was not specified, then display the usage information
        usage()
        # Display an error message to user
        print('ERROR: No file or directory specified')
        # Exit with an error
        exit(1)
    #----------------------#
    #-- OUTPUT DIRECTORY --#
    #----------------------#
    # Optional Flag: Path to the directory where the SELinux policy module directory for $target will be created
    outdir = options('-d')
    # If no $outdir is specified, then default to the user's current working directory
    outdir = getcwd()
    #------------------#
    #-- CUSTOM LABEL --#
    #------------------#
    # Optional Flag: Custom label to use for the SELinux policy module
    label = options('-l')
    #-----------------#
    #-- MODULE NAME --#
    #-----------------#
    # Optional Flag: Custom name to use for the SELinux policy module name
    name = options('-n')
    #-----------------#
    #-- MODULE TYPE --#
    #-----------------#
    # Optional Flag: Specify the SELinux type (eg. 'bin_t' for the module attributes
    modtype = options('-t')
    # Return the arguments
    return(target, outdir, label, name, modtype)

def options(flag):
    try:
        # Define the $value of the specified $flag to be the next index
        value = [argv[i + 1] for i in range(2, len(argv)) if argv[i].strip() == flag]
    except IndexError:
        # If the $flag was specified but there was no value, then display an error message to user
        print(f"ERROR: Please pass the value for the flag: '{flag}'")
        # Exit with an error
        exit(1)
    try:
        # Define the $value and remove extraneous whitespace
        value = value[0].strip()
    except IndexError:
        # If the $flag was not found, then return False
        return(False)
    # Check if the $value for $flag starts with a dash. This means that there was no value specified by the user and another flag is being mistaken as the value
    if value.startswith('-'):
        # If the $flag was specified but there was no value, then display an error message to user
        print(f"ERROR: Please pass the value for the flag: '{flag}'")
        # Exit with an error
        exit(1)
    # Return the $value for the specified $flag
    return(value)

def is_exists(target):
    # If $target is a valid directory or valid file, then return True
    if Path(target).is_dir() or Path(target).is_file(): return(True)
    # Otherwise, display an error message to user
    print(f"ERROR: Unable to find the following file or directory: '{target}'")
    # Exit with an error
    exit(1)

def selinux_changes(target):
    # Change all periods in $target to underscores
    target = target.replace('.', '_')
    # Change all pluses to in $target to 'pp'
    target = target.replace('+', 'p')
    # SELinux does not utilize /usr/lib64 and will instruct users to specify '/usr/lib' instead
    target = target.replace('/usr/lib64', '/usr/lib')
    # Return all changes made to $target
    return(target)

def copy_template(dest):
    try:
        # Copy the $src template directory to $dest
        copytree(template, dest)
    except FileExistsError:
        # If the directory already exists at $dest, display an error message to user
        raise FileExistsError(f"ERROR: Directory already exists: '{dest}'")

class edit:
    def __init__(self, dct):
        # Define and verify the SELinux policy module and shell script used for labelling are present in $template
        [template_te, label_sh] = self.define()
        # Edit the SELinux policy module to specify the correct names and attributes
        self.contents_te = self.file(dct, template_te)
        self.contents_label = self.file(dct, label_sh)

    def __call__(self):
        return(self.contents_te, self.contents_label)

    def define(self):
        # Define the SELinux policy module file that should exist within $template
        template_te = PurePath(template).joinpath('template.te')
        # Define the shell script that labels that should exist within $template
        label_sh = PurePath(template).joinpath('label.sh')
        # Verify both of these files exist
        is_exists(template_te)
        is_exists(label_sh)
        # Return both file variables
        return(template_te, label_sh)

    def file(self, dct, filename):
        # Open $filename and obtain its contents
        with open(filename, 'r') as f: contents = f.readlines()
        # Perform the changes
        for placeholder in dct: contents = [entry.replace(placeholder, dct[placeholder]) for entry in contents]
        # Return $contents
        return(contents)

class write:
    def __init__(self, contents_te, contents_label, dest):
        try:
            # Create $dest; equivalent to `mkdir -p`
            Path(dest).mkdir(parents = True)
        except FileExistsError:
            # If the directory already exists then do nothing
            pass
        except:
            # All other errors will lead to an error message
            print(f"ERROR: Unable to create directory: '{dest}'")
            # Exit with an error
            exit(1)
        # Define the SELinux policy module file that will be written in $dest, where the 'template.te' filename is renamed to reflect the $selinux_changes_target, which is also used as the module name
        template_te = PurePath(dest).joinpath(self.renamed_template_te(contents_te))
        # Write the SELinux policy module to specify the correct names and attributes
        self.file(contents_te, template_te)
        # Define the shell script that labels that will be written in $dest
        label_sh = PurePath(dest).joinpath('label.sh')
        # Write the shell script that applies the SELinux policy module label to specify the correct name and path
        self.file(contents_label, label_sh)
 
    def renamed_template_te(self, contents_te):
        try:
            # Obtain the first entry of $contents, which corresponds to the first line of $template_te
            module_name = contents_te[0]
        except IndexError:
            # If the first line of $template_te could not be obtained (the file is empty), then display an error message to user
            print(f"ERROR: The specified template SELinux policy module file is empty: '{template_te}'")
            # Exit with an error
            exit(1)
        try:
            # Define the full path to the new SELinux policy module file, renamed from 'template.te'. The name is created by splitting the $module_name via spaces to obtain the list: ['module', $name, '1.0.0.0;']. Then, obtain only the $name and remove all extraneous whitespace, making sure to add the '.te' extension for the filename
            renamed_template_te = f"{module_name.split()[1].strip()}.te"
        except IndexError:
            # If the full path to the new SELinux policy module file could not be defined above, then display an error message to user
            print(f"ERROR: Unable to obtain the module name from the specified template SELinux file: '{template_te}'")
            # Exit with an error
            exit(1)
        # Return the renamed $template_te
        return(renamed_template_te)

    def file(self, contents, filename):
        # Overwrite $filename with the new $contents 
        with open(filename, 'w') as f: f.write(''.join(contents))

############
### MAIN ###
############
def main(target, outdir, label, name, modtype):
    # Verify $target is a valid file or directory
    is_exists(target) 
    # Verify $outdir is a valid directory (if $outdir is not False)
    if outdir: is_exists(outdir)
    # Obtain the attributes of the current type associated with $target
    [_, _, attributes] = seinfox(target, False, False, True)
    # If a specific module type has been specified for the module's attributes
    if modtype is not False: attributes = ignore_alias(description(modtype, True))
    # Join the attributes to create a string
    attributes = ' '.join(attributes)
    # Perform SELinux specific changes to $target and remove its path 
    selinux_changes_target = PurePath(selinux_changes(target)).name
    # Perform SELinux specific changes only the path, not $target itself
    selinux_changes_target_path = PurePath(selinux_changes(PurePath(target).parent.as_posix())).joinpath(PurePath(target).name)
    # Create a dictionary to contain the placeholders within the template.te file and the values will be the replacements
    dct = {'ATTRIBUTE': attributes, 'NAME_PATH': selinux_changes_target_path.as_posix(), 'NAME_t': f"{selinux_changes_target}_t"}
    # If $label has been specified, then set the 'NAME_t' placeholder to $label 
    if label is not False: dct['NAME_t'] = label
    # If $name has been specified, then create the 'module NAME' entry and set its replacement to 'module $name' instead
    if name is not False: dct['module NAME'] = f"module {name}"
    dct['NAME'] = selinux_changes_target
    # Edit the template files to reflect $target
    [contents_te, contents_label] = edit(dct)()
    # If $outdir is set to False, then return the contents of the 'template.te' file and the 'label.sh' shell script
    if outdir is False: return(contents_te, contents_label)
    # Define the destination directory that will contain the new SELinux policy module for $target.
    dest = PurePath(outdir).joinpath(selinux_changes_target)
    # If $name has been specified, then set the $dest directory to be $outdir/$name
    if name is not False: dest = join(outdir, name)
    # Create the SELinux policy module directory for $target using $template
    write(contents_te, contents_label, dest)

#############
### START ###
#############
if __name__ == '__main__':
    # Verify $template is a valid directory
    is_exists(template)
    # Verify the $seinfo binary exists, used to obtain the attributes of SELinux types
    is_exists(seinfo)
    # Parse user-specified arguments
    [target, outdir, label, name, modtype] = args()
    # Execute the main script
    main(target, outdir, label, name, modtype)
