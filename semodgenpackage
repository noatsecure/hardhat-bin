#!/usr/bin/env python
from importlib.machinery import SourceFileLoader
from importlib.util import module_from_spec,spec_from_loader
from pathlib import Path,PurePath
from re import search,sub
from subprocess import run
from sys import argv

######################
### CUSTOM MODULES ###
######################
def custom_module(filename):
    # Define the name based on the filename
    name = PurePath(filename).name
    # Create $spec that is used to load the module
    spec = spec_from_loader(name, SourceFileLoader(name, filename))
    # Define the module
    mod = module_from_spec(spec)
    # Load the module based on $spec
    spec.loader.exec_module(mod)
    # Return the module object
    return(mod)

#-------------#
#-- SEINFOX --#
#-------------#
# Since the `seinfox` module does not have the '.py' extension, it needs to be loaded in a more complicated way
seinfox = custom_module(PurePath(Path(argv[0]).resolve().parent).joinpath('seinfox').as_posix())

# Define the contexts function as $contexts
contexts = seinfox.contexts

#------------------#
#-- SEMODGENAUTO --#
#------------------#
# Load the `semodgentarget` python script
semodgentarget = custom_module(PurePath(Path(argv[0]).resolve().parent).joinpath('semodgentarget').as_posix())

# Define the main function as $semodgentarget
semodgentarget = semodgentarget.main

#############
### USAGE ###
#############
def usage():
    name = PurePath(argv[0]).name
    print(f"NAME\n\t{name} - python script to automatically generate a SELinux policy module for all binaries and libraries within the specified package\n")
    print(f"SYNOPSIS\n\t{name} package_name /path/to/output_dir/\n")
    print(f"DESCRIPTION\n\t{name} is a Python script provided by the HardHat project that automatically generates a single SELinux policy module (label only) for all of the binaries within the package labelled as 'bin_t', and all of the libraries within the package labelled as 'lib_t'. The label will be based on the package's name, eg. Binaries within the 'coreutils' package will have the label 'coreutils_bin_t', and the libraries will be labelled 'coreutils_lib_t'.\n\n\tArgument 2 is optional, and it specifies the directory to output the SELinux policy module directory to. By default, this is set to: '/usr/local/share/hardhat-selinux-local'\n")
    print(f"EXAMPLE\n\t1. {name} coreutils\n\n\t2. {name} gzip /home/user/selinux-labels\n")
    print("\n")

#################
### FUNCTIONS ###
#################
def error(msg):
    # Display error message to user
    print(f"ERROR: {msg}")
    # Exit with an error
    exit(1)

def warn(msg):
    # Display warning message to user
    print(f"WARN: {msg}")

def args():
    # Check if the user has specified the help flag (any argument)
    if any([True for arg in argv if arg == '-h']):
        # If so, then display the usage information
        usage()
        # Exit
        exit(0)
    try:
        # Argument 1: Name of the package
        package = argv[1]
    except IndexError:
        # If not specified, then display an error message and exit
        error("Argument 1: Name of the package.")
    try:
        # Argument 2 (Optional): Output directory
        outdir = Path(argv[2]).expanduser().resolve()
    except IndexError:
        # Default output directory
        outdir = Path('/usr/local/share/hardhat-selinux-local').expanduser() 
    return(package, outdir)

def rpm(package):
    # Execute the rpm command to list all files and directories associated with $package
    cmd = run(['/usr/bin/rpm', '--list', '--query', package], capture_output = True)
    # If the command failed, most likely due to the $package not existing, then exit with an error
    if cmd.returncode != 0: error(f"Invalid package: '{package}'")
    # The output will be a string, so convert it into a list and return
    return(cmd.stdout.decode().split('\n'))

def parse(stdout):
    # Remove empty and duplicate entries
    lst = set([entry.strip() for entry in stdout if entry])
    # Remove all entries that start with the specified string
    lst = [entry for entry in lst if not entry.startswith('/usr/lib/.build-id')]
    # Define a set that contains entries within $lst that will be removed
    rmlst = set()
    # Iterate through each entry within $lst and identifies all another entries that start with the current one. For example, if the current $entry is '/etc/package', then the $other_entry '/etc/package/file1.txt' and the $other_entry '/etc/package/directory1' will both be added to the $rmlst set
    for entry in lst: set([rmlst.add(other_entry) for other_entry in lst if (not entry == other_entry) and (other_entry.startswith(entry))])
    # Keep only entries that are no in $rmlst
    lst = sorted([entry for entry in lst if entry not in rmlst]) 
    # Return $lst
    return(lst)

def custom_labels(package):
    # Create a dictionary to hold the custom labels as keys and a tuple of their associated directories as the value
    labels = dict()
    # Use the package name to define the following labels
    labels[f"{package}_bin_t"] = ('/bin', '/usr/bin')
    labels[f"{package}_etc_t"] = ('/etc')
    labels[f"{package}_sbin_t"] = ('/sbin', '/usr/sbin')
    # The custom label for the library directories are dependent on the package name. Normally the label for these directories will be: $name_libs_t, but for packages like 'openssl-libs' for example, the label looks redundant: 'openssl-libs_lib_t'. So to mediate this the associated directories are first defined
    lib_labels = ('/lib', '/lib64', '/usr/lib', '/usr/lib64')
    # Next, check if the $package name ends with either string
    if package.endswith(('-lib', '-libs')):
        # If so, then do not include the '_lib_t'. Eg. the label for 'openssl-libs' is 'openssl-libs_t' instead of the messy 'openssl-libs_lib_t'
        labels[f"{package}_t"] = lib_labels
    else:
        # Otherwise, add the 'lib_t' string. Eg. the label for 'gzip' is 'gzip_lib_t'
        labels[f"{package}_lib_t"] = lib_labels
    # Return the $labels dictionary
    return(labels)
 
def default_labels(lst):
    defaults = dict()
    # Iterate through all nested lists within $lst
    for entry in lst:
        try:
            # Obtain the current SELinux label for $entry
            [_, _, label] = contexts(entry)
        except PermissionError:
            # If the specified path is not accessible by the user that executed this script, then display a warning message to user
            warn(f"Unable to obtain the SELinux context for the following entry due to a permission error. You may need to run this script as root: '{entry}'")
            # Set $label to False
            label = False
        except FileNotFoundError:
            # If $entry is not a valid file, then display a warning message to user
            warn(f"The following entry is not a valid file. This error occurs when a package's symlink is to a non-existent file and is often harmless: '{entry}'")
            # Set $label to False
            label = False
        defaults[entry] = label
    return(defaults)

def regex(entry):
    # Use regex to ensure the labels for libraries are not version specific. For example, a generic 'libtest.so' will generally be a symlink to 'libtest.so.1.1.1', a specific version. This replacement converts 'libtest.so' --> 'libtest.so(.*)?' and 'libtest.so.1.1.1' --> 'libtest.so(.*)?'. They are now both the same so future updates to this library are covered
    entry = sub(r'.so.[a-zA-Z0-9].+$', '.so(.*)?', entry)
    # For directories include all files within the directory by adding '(.*)?' to the end of the directory name
    if Path(entry).is_dir(): entry = f"{entry}(.*)?" 
    # SELinux doesn't handle '/lib64' and '/usr/lib64', so they will need to be converted to '/usr/lib'
    entry = sub(r'(/lib64|/usr/lib64)', '/usr/lib', entry)
    # Return the current $entry
    return(entry)

def default_types(lst, custom):
    # Create a set containing all default types within $lst
    defaults_uniq = set([nst_lst[1] for nst_lst in lst])
    # Iterate through each entry within $defaults_uniq
    for entry in defaults_uniq:
        try:
            # Check if $entry was found in the $custom dictionary, containing the custom labels for the current $package
            custom[entry]
        except KeyError:
            # If $entry is a generic (eg. 'bin_t', 'lib_t'), then continue to the next $entry
            continue
        try:
            # Using regular expressions, obtain the default label. Eg. 'test_lib_t' = 'lib_t', and 'test_bin_t' = 'bin_t', etc.
            default_type = search(r'(?<=-|_)[\w]+_t$', entry).group()
        except AttributeError:
            error(f"Unable to determine default type (eg. 'bin_t', 'lib_t') for the custom label: '{entry}'")
        # All of the sbin related directories use the SELinux label 'bin_t'
        if default_type == 'sbin_t': default_type = 'bin_t'
        # For package names ending with 'libs_t', correct the label to be 'lib_t'
        if default_type == 'libs_t': default_type = 'lib_t'
        # Iterate through the nested lists within $lst
        for nst_lst in lst:
            # If the default type is $entry, then change it to $default_type
            if nst_lst[1] == entry: nst_lst[1] = default_type
    # Return $lst
    return(lst)

def generate(package, lst):
    # Create a name for the SELinux policy module
    name = f"{PurePath(package).name}_label"
    # Create a set containing all default types within $lst
    defaults_uniq = set([(nst_lst[1], nst_lst[2]) for nst_lst in lst])
    # Simply define an example file/directory for usage below when generating a SELinux policy module file and label shell script
    example_target = lst[0][0]
    # Define a dictionary to contain each unique entry within $defaults_uniq as the key, and the value being the SELinux policy module
    te = {}
    # Define a dictionary to contain each unique entry within $defaults_uniq as the key, and the value being the label shell script
    label = {}
    # Iterate through each tuple within $defaults_uniq
    for tple in defaults_uniq:
        # Obtain the SELinux policy module contents and label shell script contents for $example_target
        [template_te, template_label] = semodgentarget(example_target, False, tple[1], name, tple[0])
        # Add the SELinux policy module contents list to the $te dictionary, using the custom label as the key
        te[tple[1]] = template_te
        # Add the label shell script contents list to the $label dictionary, using the custom label as the key
        label[tple[1]] = template_label 
    # Return the dictionaries
    return(label, te)

def add_label(lst, label):
    # Iterate through the keys within the $label dictionary in order to remove the $example_target from the label contents list
    for key in label:
        # Define the contents for the current $key
        contents = label[key]
        # Define the shebang ('#!/bin/sh')
        shebang = contents[0]
        # Define the contents as every entry within the $contents[1] list except for $example_target
        contents = contents[1].split()[0:-1]
        # Add the combined lists above as the new contents for $label[key]
        label[key] = f"{shebang}{' '.join(contents)}"
    # Utilize regular expressions to ensure libraries and directories are properly covered
    for nst_lst in lst: nst_lst[0] = regex(nst_lst[0])
    # Iterate through each key within the $label dictionary
    for key in label:
        # Iterate through each nested list within $lst
        for nst_lst in lst:
            # Check if the custom label within $nst_lst is the same as the current $key
            if nst_lst[2] == key:
                # If so, then add the proper label shell script contents to $nst_lst
                nst_lst.append(f"{label[key]} \"{nst_lst[0]}\";\n")
    # Return $lst
    return(lst)

def create_label(lst):
    labels = [nst_lst[-1] for nst_lst in lst]
    try:
        shebang = labels[0].split('\n')[0]
    except IndexError:
        error(f"Unable to obtain the shebang from the last index of the first entry (shown) from the $lst list:\n\n{lst[0]}\n")
    # From each entry within $labels, split via newline and obtain the contents that should be in index 1. Index 0 = shebang, and index 2 = '' since it's a newline. Convert it to a set to remove duplicates and then sort
    labels = sorted(set([entry.split('\n')[1] for entry in labels]))
    # Join all entries via the newline to create a string
    labels = '\n'.join(labels)
    # Define the label shell script
    labels = f"{shebang}\n{labels}"
    # Return the $labels string
    return(labels)

def create_te(te):
    try:
        # Use the first entry within $te as a template SELinux policy module
        template = list(te.values())[0]
    except IndexError:
        # If the $te dictionary is empty, then display an error message to user and exit
        error("No SELinux policy modules were generated")
    # Obtain the entry within $te for each $key that contains the attributes for the newly defined type for the specific custom label
    te_attributes = [entry for key in te for entry in te[key] if entry.strip().startswith('attribute')]
    try:
        # Define the start of the line within the policy module that defines all of the attributes
        start = search(r'(^ +|)attribute( |)', te_attributes[0]).group()
    except AttributeError:
        # If the regular expression search above failed, then display an error message to user and exit
        error(f"Unable to utilize regular expressions to obtain the start of the 'attribute' entry for the following SELinux policy module contents:\n\t'{entry[0]}'")
    # Define a set that will hold all attributes from all entries within $te 
    attributes = set()
    # Iterate through each of the attribute lines within $te_attributes
    for entry in te_attributes:
        # Using the $start string, split the current $entry into two parts: 0) the start of the line containing the 'attribute' string, 1) all of the attributes to define
        entry = entry.split(start, 1)
        # Split the contents section of $entry via the comma delimiter, remove extraneous whitespace and remove the ';' at the end of the line
        contents = [x.replace(';', '').strip() for x in entry[1].split(', ')]
        # Skipping the custom type in index 0, add all of the attributes for $entry to the $attributes set
        [attributes.add(x) for x in set(contents[1:])]
    # Sort the set of $attributes and join it via the comma delimiter used to previously split it. Add the $start string as well as the ending ';\n' string to complete the attribute line
    attributes = f"{start}{', '.join(sorted(attributes))};\n"
    # Re-create the $template list by adding all original entries to the output list except for the original 'attribute' line, where the $attributes string is now used instead
    template = [attributes if entry.strip().startswith('attribute') else entry for entry in template]
    # Obtain all entries within $te that defines the custom type (eg. 'type test_etc_t', 'test_lib_t') and sort them
    te_types = sorted([entry for key in te for entry in te[key] if entry.strip().startswith('type')])
    # Re-create the $template list again, where all custom types within $te_types are now put in place of the original type in $template
    template = [''.join(te_types) if entry.strip().startswith('type') else entry for entry in template]
    # Convert the $template into a string by joining all entries together
    template = ''.join(template)
    # Return $template
    return(template)

def write(label, te, outdir):
    try:
        # Obtain the module name from the $te string
        name = search(r'[a-zA-Z0-9-_]+_label', te).group()
    except AttributeError:
        # If the regular expression failed, then display an error message to user and exit
        error(f"Unable to obtain module name from the following $te contents:\n\n{te}")
    # Define the output directory that will contain the SELinux policy module .te file and the label.sh shell script
    outdir = PurePath(outdir).joinpath(name)
    try:
        # Create the output directory if it does not already exist
        Path(outdir).mkdir()
    except FileExistsError:
        # If the directory already exists, then do nothing
        pass
    # Define the full path to the SELinux policy module .te file
    filename_te = PurePath(outdir).joinpath(f"{name}.te")
    # Define the full path to the label.sh shell script
    filename_label = PurePath(outdir).joinpath('label.sh')
    # Write $te
    with open(filename_te, 'w') as f: f.write(te)
     # Write $label
    with open(filename_label, 'w') as f: f.write(f"{label}\n")

############
### MAIN ###
############
def main(package, outdir):
    # Obtain a list of all files and directories associated with $package
    stdout = rpm(package)
    # Clean the $stdout list to keep only valid entries
    lst = parse(stdout)
    # Define custom SELinux labels that will be used for each file and directory
    custom = custom_labels(package)
    # Obtain the default SELinux labels for each file and directory
    defaults = default_labels(lst)
    # Add the default and custom labels to create a list of lists in the format of: [['/path/to/file', 'default label', 'custom label'], ...]
    lst = [[entry, defaults[entry], key] for entry in lst for key in custom if entry.startswith(custom[key]) and defaults[entry]]
    # If the default types for any of the nested lists within $lst are a custom label (eg. 'openssl-libs_t' instead of 'lib_t'), then fix it
    lst = default_types(lst, custom)
    # Generate the SELinux policy module and 
    [label, te] = generate(package, lst)
    # Edit the labels within $label for each entry within $lst
    lst = add_label(lst, label)
    # Create the output $label file
    label = create_label(lst)
    # Create the output $te file
    te = create_te(te)
    # Write the SELinux policy module and label shell script
    write(label, te, outdir)

#############
### START ###
#############
if __name__ == '__main__':
    # Arguments
    [package, outdir] = args()
    # Execute the main script
    main(package, outdir)
